/**
 * i have this [tools].tsx file in my next.js app
 * and i wannt to compile all routes to static html files
 * but when running next build and next export,
 * it produces js files not html files
 * and i want html files.
 * but when building using:
 * next build
 * next export
 * i get this error: warn  - Detected next.config.js, no exported configuration found. https://nextjs.org/docs/messages/empty-configuration
info  - Linting and checking validity of types
Failed to compile.

Module not found: Error: Can't resolve './C:/Users/sanus/AppData/Roaming/nvm/v18.15.0/node_modules/next/dist/client/next.js' in 'D:\pdfequips'


> Build failed because of webpack errors
info  - Creating an optimized production build .
 */
import store from "../public/store";

type _t = keyof typeof store;

import Head from "next/head";
import NavBar from "../components/NavBar";
import Tool from "../Tool";

type data_type = {
  title: string;
  description: string;
  color: string;
  type: string;
};

export async function getStaticPaths() {
  const paths = Object.keys(routes).map((key) => ({
    params: { tool: key.substring(1) },
  }));
  return {
    paths,
    fallback: false,
  };
}
export async function getStaticProps({
  params,
}: {
  params: {
    tool: string;
  };
}) {
  const item = routes[`/${params.tool}` as keyof typeof routes].item;
  return { props: { item } };
}

export default ({ item }: { item: data_type }) => {
  return (
    <>
      <Head>
        <title>{item.title}</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
        <link
          rel="stylesheet"
          href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        ></link>
      </Head>
      <NavBar />
      <Tool data={item} />
    </>
  );
};
export const routes = {
  "/merge-pdf": { item: store["Merge_PDF"] },
  "/split-pdf": { item: store["Split_PDF"] },
  "/compress-pdf": { item: store["Compress_PDF"] },
  "/pdf-to-powerpoint": { item: store["PDF_to_Powerpoint"] },
  "/jpg-to-pdf": { item: store["JPG_to_PDF"] },
  "/word-to-pdf": { item: store["WORD_to_PDF"] },
  "/powerpoint-to-pdf": { item: store["POWERPOINT_to_PDF"] },
  "/excel-to-pdf": { item: store["EXCEL_to_PDF"] },
  "/html-to-pdf": { item: store["HTML_to_PDF"] },
  "/pdf-to-jpg": { item: store["PDF_to_JPG"] },
  "/pdf-to-word": { item: store["PDF_to_WORD"] },
  "/pdf-to-excel": { item: store["PDF_to_EXCEL"] },
  "/pdf-to-pdf-a": { item: store["PDF_to_PDF_A"] },
};

/**
 * i have a compiled next ssg app in my out directory
 * and in my public directory i have a python flask app.
 * i want to serve the next app which contains a bunch of html files with my flask app
 * here is my code so far: 
 * from flask import Flask, render_template, send_from_directory
from jinja2 import TemplateNotFound

def get_routes_handler(app):
    @app.route('/', methods=['GET'])
    def index():
        try:
            return render_template(f'/index.html')
        except TemplateNotFound:
            return "404 Not Found", 404
    
    @app.route('/<path:path>', methods=['GET'])
    def serve_static(path):
        try:
            return render_template(f'/out/{path}.html')
        except TemplateNotFound:
            return "404 Not Found", 404

    @app.route('/_next/<path:path>', methods=['GET'])
    def serve_static_files(path):
        try:
            return send_from_directory("/out/_next", path)
        except TemplateNotFound:
            return "404 Not Found", 404


  but this is always returning 404 Not Found
  my app tree
  pdfequis
    /out(next app)
    /public
      -/api (python application)
*/

****************************************************************

"""
    i have a compiled next ssg app in my out directory
    and in my public directory i have a python flask app.
    i want to serve the next app which contains a bunch of html files with my flask app
    here is my code so far:
"""

from flask import Flask, render_template, send_from_directory
from jinja2 import TemplateNotFound

def get_routes_handler(app):
    # setting templates directory for get routes
    app.jinja_loader = FileSystemLoader('/out') 
    @app.route('/', methods=['GET'])
    def index():
        try:
            return render_template(f'/index.html')
        except TemplateNotFound:
            return "404 Not Found", 404
    
    @app.route('/<path:path>', methods=['GET'])
    def serve_static(path):
        try:
            return render_template(f'/out/{path}.html')
        except TemplateNotFound:
            return "404 Not Found", 404

    @app.route('/_next/<path:path>', methods=['GET'])
    def serve_static_files(path):
        try:
            return send_from_directory("/out/_next", path)
        except TemplateNotFound:
            return "404 Not Found", 404
        

# in my app.py file
app = Flask(__name__);
get_routes_handler(app)

if __name__ == "__main__":
    app.run(debug=True)


"""but this is always returning 404 Not Found
    my app tree
    pdfequis
    /out(next app)
    /public
        -/api (python application)
    also its worth mentioning that 
    i don't have the templates directory, 
    my out directory contains just output html files and __next directory
    
"""

****************************************************************
this is my form submit handler, i want to extract the logic of the download to another function
and i want to download the converted file with the name of the original uploaded file

also decrease any redundancy in the code:

const handleUpload = async (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();

  const files = (fileInput.current as HTMLInputElement).files;
  if (!files) return;

  const formData = new FormData();
  for (let i = 0; i < files.length; i++) {
    formData.append("files", files[i]);
  }
  let url;
  if (process.env.NODE_ENV === "development") {
    url = `http://127.0.0.1:5000/${endpoint}`;
    console.log("Running in development mode");
  } else {
    url = `/${endpoint}`;
  }
  console.log(url);

  try {
    const response = await axios.post(url, formData, {
      responseType: "blob",
    });
    console.log(response.data);

    if (
      data.type == ".jpg" ||
      data.type == ".docx" ||
      data.type == ".html" ||
      data.type == ".xlsx"
    ) {
      const binaryData = [];
      console.log(response.data);
      binaryData.push(response.data);
      const url = URL.createObjectURL(
        new Blob(binaryData, { type: "application/pdf" })
      );
      if (downloadBtn && downloadBtn.current) {
        downloadBtn.current.href = url;
      }
      downloadBtn.current?.click();
    } else if (data.type === ".pdf") {
      const url = URL.createObjectURL(new Blob([response.data]));
      let output;
      if (downloadBtn && downloadBtn.current) {
        if (data.title == "PDF to WORD") {
          output = "output.docx";
        } else if (data.title == "PDF to EXCEL") {
          output = "output.xlsx";
        } else if (data.title == "EXCEL to PDF") {
          output = "new_output.pdf";
        } else if (data.title == "PDF to Powerpoint") {
          output = "new_output.pptx";
        } else {
          output = "output.pdf";
        }
        downloadBtn.current.setAttribute("download", output);
        downloadBtn.current.href = url;
      }
      downloadBtn.current?.click();
    } else if (data.type == ".pptx") {
      const url = URL.createObjectURL(new Blob([response.data]));
      if (downloadBtn && downloadBtn.current) {
        downloadBtn.current.setAttribute("download", "output.pdf");
        downloadBtn.current.href = url;
      }
      downloadBtn.current?.click();
    }
    setShowErrorMessage(false);

    if (response.status !== 200) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  } catch (error) {
    console.error("Error uploading file:", error);
    // let _b = new Blob(
    //   (error as errorType).response.data as unknown as BlobPart[],
    //   { type: "application/json" }
    // );
    // error.response.data.text().then(validString => {
    //   console.log(validString);
    // })
    // (error as errorType).response.data.text().then((jsonString) => {
    //   setErrorMessage(JSON.parse(jsonString).error);
    // });

    setShowErrorMessage(true);
    setErrorMessage((error as errorType)?.response?.data.error);
  }
};


************************************************
you forgot what we were talking about
here is the full task i asked you to do earlier:
 /**
   * i want a bootstrap sidebar (always visible)
   * with two sections: edit-area & options
   * edit-area will take about 75% width, and options will take the rest
   * the options area has a h5, it should be centered with a little bottom border
   * the edit-page should look like a card or card body with padding,
   * please use bootstrap classes if possible, otherwise use regular css
   * the button should have a pulse animation
   * this is my html and i'm using tsx by the way:
   */
  return (
    <aside className="edit-page">
      <section className="edit-area"></section>
      <section className="options">
        <h5 className="text-uppercase">{title} options</h5>
        <button
          className={`submit-btn btn btn-lg text-white position-relative overflow-hidden ${title.replace(
            /[\s/]+/g,
            "-"
          )}`}
        >
          Convert to {type.replace(/\./, "")}
        </button>
      </section>
    </aside>
  );
  
try using sass for the css, and try to use as much as bootstrap classes as possible
you can change the markup but remember that i'm using tsx,

also the pulse animation should be implemented using box-shadow here is a starting point:

@-webkit-keyframes pulse {
  0% {
    -webkit-box-shadow: 0 0 0 0 rgba(204,169,44, 0.4);
  }
  70% {
      -webkit-box-shadow: 0 0 0 10px rgba(204,169,44, 0);
  }
  100% {
      -webkit-box-shadow: 0 0 0 0 rgba(204,169,44, 0);
  }
}
@keyframes pulse {
  0% {
    -moz-box-shadow: 0 0 0 0 rgba(204,169,44, 0.4);
    box-shadow: 0 0 0 0 rgba(204,169,44, 0.4);
  }
  70% {
      -moz-box-shadow: 0 0 0 10px rgba(204,169,44, 0);
      box-shadow: 0 0 0 10px rgba(204,169,44, 0);
  }
  100% {
      -moz-box-shadow: 0 0 0 0 rgba(204,169,44, 0);
      box-shadow: 0 0 0 0 rgba(204,169,44, 0);
  }
}

use the variable $pdf-color instead of these rgba colors

****************************************************************
the function should also prevent attacks as mentioned here:

Yes, there is a possibility that your website can get hacked through the uploaded HTML file. When you allow users to upload files to your website, you are opening up a potential attack vector for malicious actors to exploit. If the uploaded file contains malicious code, it can potentially compromise the security of your website and your users.

To prevent such attacks, it is important to properly validate and sanitize the uploaded file before processing it. You can use a library like bleach or html5lib to sanitize the HTML code and remove any potentially malicious code or tags. Additionally, you can restrict the type and size of files that users can upload, and limit the permissions of the user account that is used to process the uploaded files.

It is also recommended to run your application in a secure environment, such as a virtual private server (VPS) or a cloud hosting platform, and to keep your server and software up-to-date with the latest security patches. You can also consider implementing additional security measures, such as two-factor authentication, HTTPS encryption, and rate limiting to prevent brute-force attacks.

In summary, while allowing users to upload files to your website can be a useful feature, it is important to take appropriate security measures to prevent potential security breaches.

****************************************************************

the function should not wait for the page to fully load, this could take a long time.

and also right now it's returning empty corrupted pdf file

****************************************************************

i want to ssg my entire website using next.js and i want to create multiple instances fo it for each language i support, i'm building a multi-lingual website
but the english is my default language, i.e going to any route without /lang/route will take to my english version.

and other languages like arabic should be served like so: my-website.com/ar/route

in my app public/locales directory i have en.json and ar.json files

i want next.js to detect these files if added and generate new routes for it automatically without having me to create a new [file] for each language

i want to use next.js only and not anyother library or framework


****************************************************************
depending on the tool object i want another object called edit_page_titles which contains keys same as the tool keys
each with it's corresponding title which is the tool title + the word "options" or just the tool title if the text is long
export const tool = {
  Merge_PDF: {
    title: "Merge PDF",
    description: "Combine multiple PDF files into one document",
    color: "var(--red)",
    type: ".pdf",
    to: "/merge-pdf",
  },
  Split_PDF: {
    title: "Split PDF",
    description: "Divide one PDF file into multiple documents",
    color: "var(--orange)",
    type: ".pdf",
    to: "/split-pdf",
  },
  Compress_PDF: {
    title: "Compress PDF",
    description: "Reduce the file size of a PDF while maintaining quality",
    color: "var(--green)",
    type: ".pdf",
    to: "/compress-pdf",
  },
  PDF_to_Powerpoint: {
    title: "PDF to Powerpoint",
    description: "Convert PDF files to editable Powerpoint presentations",
    color: "#C13B1B",
    type: ".pdf",
    to: "/pdf-to-powerpoint",
  },
  JPG_to_PDF: {
    title: "JPG to PDF",
    description: "Convert JPG image files to PDF documents",
    color: "#f1c40f",
    type: ".jpg",
    to: "/jpg-to-pdf",
  },
  WORD_to_PDF: {
    title: "WORD to PDF",
    description: "Convert Microsoft Word files to PDF documents",
    color: "#1B5EBE",
    type: ".docx",
    to: "/word-to-pdf",
  },
  POWERPOINT_to_PDF: {
    title: "POWERPOINT to PDF",
    description: "Convert Microsoft Powerpoint files to PDF documents",
    color: "#C13B1B",
    type: ".pptx",
    to: "/powerpoint-to-pdf",
  },
  EXCEL_to_PDF: {
    title: "EXCEL to PDF",
    description: "Convert Microsoft Excel files to PDF documents",
    color: "#10793F",
    type: ".xlsx",
    to: "/excel-to-pdf",
  },
  HTML_to_PDF: {
    title: "HTML to PDF",
    description: "Convert HTML web pages to PDF documents",
    color: "rgb(228, 77, 38)",
    type: ".html",
    to: "/html-to-pdf",
  },
  PDF_to_JPG: {
    title: "PDF to JPG",
    description: "Convert PDF files to JPG image files",
    color: "#f1c40f",
    type: ".pdf",
    to: "/pdf-to-jpg",
  },
  PDF_to_WORD: {
    title: "PDF to WORD",
    description: "Convert PDF files to Microsoft Word documents",
    color: "#1B5EBE",
    type: ".pdf",
    to: "/pdf-to-word",
  },

  PDF_to_EXCEL: {
    title: "PDF to EXCEL",
    description: "Convert PDF files to Microsoft Excel documents",
    color: "#10793F",
    type: ".pdf",
    to: "/pdf-to-excel",
  },

  PDF_to_PDF_A: {
    title: "PDF to PDF/A",
    description: "Convert PDF files to PDF/A format for long-term archiving",
    color: "#000000",
    type: ".pdf",
    to: "/pdf-to-pdf-a",
  },
};
****************************************************************
Create a separate object called action_buttons for example following this structure: {
  [key: string]: string
}
which reprecent the submit buttons text.

depending on the tool object

which contains keys same as the tool keys
each which are useful information about the button action like if the tool action is conversion
let's say the title is jpg to pdf, the action button text should be somthing like Convert to PDF
export const tool = {
  Merge_PDF: {
    title: "Merge PDF",
    description: "Combine multiple PDF files into one document",
    color: "var(--red)",
    type: ".pdf",
    to: "/merge-pdf",
  },
  Split_PDF: {
    title: "Split PDF",
    description: "Divide one PDF file into multiple documents",
    color: "var(--orange)",
    type: ".pdf",
    to: "/split-pdf",
  },
  Compress_PDF: {
    title: "Compress PDF",
    description: "Reduce the file size of a PDF while maintaining quality",
    color: "var(--green)",
    type: ".pdf",
    to: "/compress-pdf",
  },
  PDF_to_Powerpoint: {
    title: "PDF to Powerpoint",
    description: "Convert PDF files to editable Powerpoint presentations",
    color: "#C13B1B",
    type: ".pdf",
    to: "/pdf-to-powerpoint",
  },
  JPG_to_PDF: {
    title: "JPG to PDF",
    description: "Convert JPG image files to PDF documents",
    color: "#f1c40f",
    type: ".jpg",
    to: "/jpg-to-pdf",
  },
  WORD_to_PDF: {
    title: "WORD to PDF",
    description: "Convert Microsoft Word files to PDF documents",
    color: "#1B5EBE",
    type: ".docx",
    to: "/word-to-pdf",
  },
  POWERPOINT_to_PDF: {
    title: "POWERPOINT to PDF",
    description: "Convert Microsoft Powerpoint files to PDF documents",
    color: "#C13B1B",
    type: ".pptx",
    to: "/powerpoint-to-pdf",
  },
  EXCEL_to_PDF: {
    title: "EXCEL to PDF",
    description: "Convert Microsoft Excel files to PDF documents",
    color: "#10793F",
    type: ".xlsx",
    to: "/excel-to-pdf",
  },
  HTML_to_PDF: {
    title: "HTML to PDF",
    description: "Convert HTML web pages to PDF documents",
    color: "rgb(228, 77, 38)",
    type: ".html",
    to: "/html-to-pdf",
  },
  PDF_to_JPG: {
    title: "PDF to JPG",
    description: "Convert PDF files to JPG image files",
    color: "#f1c40f",
    type: ".pdf",
    to: "/pdf-to-jpg",
  },
  PDF_to_WORD: {
    title: "PDF to WORD",
    description: "Convert PDF files to Microsoft Word documents",
    color: "#1B5EBE",
    type: ".pdf",
    to: "/pdf-to-word",
  },

  PDF_to_EXCEL: {
    title: "PDF to EXCEL",
    description: "Convert PDF files to Microsoft Excel documents",
    color: "#10793F",
    type: ".pdf",
    to: "/pdf-to-excel",
  },

  PDF_to_PDF_A: {
    title: "PDF to PDF/A",
    description: "Convert PDF files to PDF/A format for long-term archiving",
    color: "#000000",
    type: ".pdf",
    to: "/pdf-to-pdf-a",
  },
};