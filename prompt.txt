/**
 * i have this [tools].tsx file in my next.js app
 * and i wannt to compile all routes to static html files
 * but when running next build and next export,
 * it produces js files not html files
 * and i want html files.
 * but when building using:
 * next build
 * next export
 * i get this error: warn  - Detected next.config.js, no exported configuration found. https://nextjs.org/docs/messages/empty-configuration
info  - Linting and checking validity of types
Failed to compile.

Module not found: Error: Can't resolve './C:/Users/sanus/AppData/Roaming/nvm/v18.15.0/node_modules/next/dist/client/next.js' in 'D:\pdfequips'


> Build failed because of webpack errors
info  - Creating an optimized production build .
 */
import store from "../public/store";

type _t = keyof typeof store;

import Head from "next/head";
import NavBar from "../components/NavBar";
import Tool from "../Tool";

type data_type = {
  title: string;
  description: string;
  color: string;
  type: string;
};

export async function getStaticPaths() {
  const paths = Object.keys(routes).map((key) => ({
    params: { tool: key.substring(1) },
  }));
  return {
    paths,
    fallback: false,
  };
}
export async function getStaticProps({
  params,
}: {
  params: {
    tool: string;
  };
}) {
  const item = routes[`/${params.tool}` as keyof typeof routes].item;
  return { props: { item } };
}

export default ({ item }: { item: data_type }) => {
  return (
    <>
      <Head>
        <title>{item.title}</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
        <link
          rel="stylesheet"
          href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
        ></link>
      </Head>
      <NavBar />
      <Tool data={item} />
    </>
  );
};
export const routes = {
  "/merge-pdf": { item: store["Merge_PDF"] },
  "/split-pdf": { item: store["Split_PDF"] },
  "/compress-pdf": { item: store["Compress_PDF"] },
  "/pdf-to-powerpoint": { item: store["PDF_to_Powerpoint"] },
  "/jpg-to-pdf": { item: store["JPG_to_PDF"] },
  "/word-to-pdf": { item: store["WORD_to_PDF"] },
  "/powerpoint-to-pdf": { item: store["POWERPOINT_to_PDF"] },
  "/excel-to-pdf": { item: store["EXCEL_to_PDF"] },
  "/html-to-pdf": { item: store["HTML_to_PDF"] },
  "/pdf-to-jpg": { item: store["PDF_to_JPG"] },
  "/pdf-to-word": { item: store["PDF_to_WORD"] },
  "/pdf-to-excel": { item: store["PDF_to_EXCEL"] },
  "/pdf-to-pdf-a": { item: store["PDF_to_PDF_A"] },
};

/**
 * i have a compiled next ssg app in my out directory
 * and in my public directory i have a python flask app.
 * i want to serve the next app which contains a bunch of html files with my flask app
 * here is my code so far: 
 * from flask import Flask, render_template, send_from_directory
from jinja2 import TemplateNotFound

def get_routes_handler(app):
    @app.route('/', methods=['GET'])
    def index():
        try:
            return render_template(f'/index.html')
        except TemplateNotFound:
            return "404 Not Found", 404
    
    @app.route('/<path:path>', methods=['GET'])
    def serve_static(path):
        try:
            return render_template(f'/out/{path}.html')
        except TemplateNotFound:
            return "404 Not Found", 404

    @app.route('/_next/<path:path>', methods=['GET'])
    def serve_static_files(path):
        try:
            return send_from_directory("/out/_next", path)
        except TemplateNotFound:
            return "404 Not Found", 404


  but this is always returning 404 Not Found
  my app tree
  pdfequis
    /out(next app)
    /public
      -/api (python application)
*/

****************************************************************

"""
    i have a compiled next ssg app in my out directory
    and in my public directory i have a python flask app.
    i want to serve the next app which contains a bunch of html files with my flask app
    here is my code so far:
"""

from flask import Flask, render_template, send_from_directory
from jinja2 import TemplateNotFound

def get_routes_handler(app):
    # setting templates directory for get routes
    app.jinja_loader = FileSystemLoader('/out') 
    @app.route('/', methods=['GET'])
    def index():
        try:
            return render_template(f'/index.html')
        except TemplateNotFound:
            return "404 Not Found", 404
    
    @app.route('/<path:path>', methods=['GET'])
    def serve_static(path):
        try:
            return render_template(f'/out/{path}.html')
        except TemplateNotFound:
            return "404 Not Found", 404

    @app.route('/_next/<path:path>', methods=['GET'])
    def serve_static_files(path):
        try:
            return send_from_directory("/out/_next", path)
        except TemplateNotFound:
            return "404 Not Found", 404
        

# in my app.py file
app = Flask(__name__);
get_routes_handler(app)

if __name__ == "__main__":
    app.run(debug=True)


"""but this is always returning 404 Not Found
    my app tree
    pdfequis
    /out(next app)
    /public
        -/api (python application)
    also its worth mentioning that 
    i don't have the templates directory, 
    my out directory contains just output html files and __next directory
    
"""

****************************************************************
this is my form submit handler, i want to extract the logic of the download to another function
and i want to download the converted file with the name of the original uploaded file

also decrease any redundancy in the code:

const handleUpload = async (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();

  const files = (fileInput.current as HTMLInputElement).files;
  if (!files) return;

  const formData = new FormData();
  for (let i = 0; i < files.length; i++) {
    formData.append("files", files[i]);
  }
  let url;
  if (process.env.NODE_ENV === "development") {
    url = `http://127.0.0.1:5000/${endpoint}`;
    console.log("Running in development mode");
  } else {
    url = `/${endpoint}`;
  }
  console.log(url);

  try {
    const response = await axios.post(url, formData, {
      responseType: "blob",
    });
    console.log(response.data);

    if (
      data.type == ".jpg" ||
      data.type == ".docx" ||
      data.type == ".html" ||
      data.type == ".xlsx"
    ) {
      const binaryData = [];
      console.log(response.data);
      binaryData.push(response.data);
      const url = URL.createObjectURL(
        new Blob(binaryData, { type: "application/pdf" })
      );
      if (downloadBtn && downloadBtn.current) {
        downloadBtn.current.href = url;
      }
      downloadBtn.current?.click();
    } else if (data.type === ".pdf") {
      const url = URL.createObjectURL(new Blob([response.data]));
      let output;
      if (downloadBtn && downloadBtn.current) {
        if (data.title == "PDF to WORD") {
          output = "output.docx";
        } else if (data.title == "PDF to EXCEL") {
          output = "output.xlsx";
        } else if (data.title == "EXCEL to PDF") {
          output = "new_output.pdf";
        } else if (data.title == "PDF to Powerpoint") {
          output = "new_output.pptx";
        } else {
          output = "output.pdf";
        }
        downloadBtn.current.setAttribute("download", output);
        downloadBtn.current.href = url;
      }
      downloadBtn.current?.click();
    } else if (data.type == ".pptx") {
      const url = URL.createObjectURL(new Blob([response.data]));
      if (downloadBtn && downloadBtn.current) {
        downloadBtn.current.setAttribute("download", "output.pdf");
        downloadBtn.current.href = url;
      }
      downloadBtn.current?.click();
    }
    setShowErrorMessage(false);

    if (response.status !== 200) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  } catch (error) {
    console.error("Error uploading file:", error);
    // let _b = new Blob(
    //   (error as errorType).response.data as unknown as BlobPart[],
    //   { type: "application/json" }
    // );
    // error.response.data.text().then(validString => {
    //   console.log(validString);
    // })
    // (error as errorType).response.data.text().then((jsonString) => {
    //   setErrorMessage(JSON.parse(jsonString).error);
    // });

    setShowErrorMessage(true);
    setErrorMessage((error as errorType)?.response?.data.error);
  }
};


************************************************
you forgot what we were talking about
here is the full task i asked you to do earlier:
 /**
   * i want a bootstrap sidebar (always visible)
   * with two sections: edit-area & options
   * edit-area will take about 75% width, and options will take the rest
   * the options area has a h5, it should be centered with a little bottom border
   * the edit-page should look like a card or card body with padding,
   * please use bootstrap classes if possible, otherwise use regular css
   * the button should have a pulse animation
   * this is my html and i'm using tsx by the way:
   */
  return (
    <aside className="edit-page">
      <section className="edit-area"></section>
      <section className="options">
        <h5 className="text-uppercase">{title} options</h5>
        <button
          className={`submit-btn btn btn-lg text-white position-relative overflow-hidden ${title.replace(
            /[\s/]+/g,
            "-"
          )}`}
        >
          Convert to {type.replace(/\./, "")}
        </button>
      </section>
    </aside>
  );
  
try using sass for the css, and try to use as much as bootstrap classes as possible
you can change the markup but remember that i'm using tsx,

also the pulse animation should be implemented using box-shadow here is a starting point:

@-webkit-keyframes pulse {
  0% {
    -webkit-box-shadow: 0 0 0 0 rgba(204,169,44, 0.4);
  }
  70% {
      -webkit-box-shadow: 0 0 0 10px rgba(204,169,44, 0);
  }
  100% {
      -webkit-box-shadow: 0 0 0 0 rgba(204,169,44, 0);
  }
}
@keyframes pulse {
  0% {
    -moz-box-shadow: 0 0 0 0 rgba(204,169,44, 0.4);
    box-shadow: 0 0 0 0 rgba(204,169,44, 0.4);
  }
  70% {
      -moz-box-shadow: 0 0 0 10px rgba(204,169,44, 0);
      box-shadow: 0 0 0 10px rgba(204,169,44, 0);
  }
  100% {
      -moz-box-shadow: 0 0 0 0 rgba(204,169,44, 0);
      box-shadow: 0 0 0 0 rgba(204,169,44, 0);
  }
}

use the variable $pdf-color instead of these rgba colors

****************************************************************

